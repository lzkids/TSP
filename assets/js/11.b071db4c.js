(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{354:function(t,_,s){"use strict";s.r(_);var a=s(42),v=Object(a.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"js面向对象与继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js面向对象与继承"}},[t._v("#")]),t._v(" js面向对象与继承")]),t._v(" "),s("h2",{attrs:{id:"面向对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[t._v("#")]),t._v(" 面向对象")]),t._v(" "),s("p",[t._v("面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。")]),t._v(" "),s("p",[t._v("js通过原型（prototype）来实现面向对象编程")]),t._v(" "),s("h2",{attrs:{id:"javascirpt继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascirpt继承"}},[t._v("#")]),t._v(" javascirpt继承")]),t._v(" "),s("h3",{attrs:{id:"_1-1原型链接继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1原型链接继承"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1.1原型链接继承")])]),t._v(" "),s("p",[t._v("​    继承本质就是复制，即重写原型对象，代之以一个新类型的实例。")]),t._v(" "),s("p",[t._v("缺点：多个实例对引用类型的操作会被篡改")]),t._v(" "),s("h3",{attrs:{id:"_1-2借用构造函数继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2借用构造函数继承"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1.2借用构造函数继承")])]),t._v(" "),s("p",[t._v("​    使用父类的构造函数来增强子类"),s("strong",[t._v("实例")]),t._v("，等同于复制父类的实例给子类（不使用原型）")]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("ul",[s("li",[t._v("只能继承父类的"),s("strong",[t._v("实例")]),t._v("属性和方法，不能继承原型属性/方法")]),t._v(" "),s("li",[t._v("无法实现复用，每个子类都有父类实例函数的副本，影响性能")])]),t._v(" "),s("h3",{attrs:{id:"_1-3组合继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-3组合继承"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1.3组合继承")])]),t._v(" "),s("p",[t._v("​     用原型链实现对"),s("strong",[t._v("原型")]),t._v("属性和方法的继承，用借用构造函数技术来实现"),s("strong",[t._v("实例")]),t._v("属性的继承。")]),t._v(" "),s("p",[t._v("缺点：组合模式的缺点就是在使用子类创建实例对象时，其原型中会存在两份相同的属性/方法。")]),t._v(" "),s("h3",{attrs:{id:"_1-4原型式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4原型式继承"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1.4原型式继承")])]),t._v(" "),s("p",[t._v("利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。")]),t._v(" "),s("p",[t._v("缺点：")]),t._v(" "),s("ul",[s("li",[t._v("原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。")]),t._v(" "),s("li",[t._v("无法传递参数")])]),t._v(" "),s("h3",{attrs:{id:"_1-5寄生式继承"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5寄生式继承"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1.5寄生式继承")])]),t._v(" "),s("p",[t._v("在原型式继承的基础上，增强对象，返回构造函数")]),t._v(" "),s("p",[t._v("缺点：（同上）")]),t._v(" "),s("h3",{attrs:{id:"_1-6es6类继承extends"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6es6类继承extends"}},[t._v("#")]),t._v(" "),s("strong",[t._v("1.6ES6类继承extends")])])])}),[],!1,null,null,null);_.default=v.exports}}]);